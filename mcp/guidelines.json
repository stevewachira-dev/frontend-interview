{
  "searchImplementation": {
    "title": "Search Implementation Guidelines",
    "content": [
      "When implementing the search feature:",
      "",
      "1. Create a custom useDebounce hook that waits 300ms before triggering search",
      "2. The hook should clean up the timer on unmount to prevent memory leaks",
      "3. Use useState to track the search input value",
      "4. Use useEffect to trigger the actual search when the debounced value changes",
      "5. Make sure the search input is a controlled component",
      "",
      "The search should filter items by:",
      "- Item name (case-insensitive partial match)",
      "- Item tags (case-insensitive, match if ANY tag contains the search term)",
      "",
      "Empty search should show all items."
    ]
  },
  "componentStructure": {
    "title": "Component Structure Guidelines",
    "content": [
      "Organize components in this structure:",
      "",
      "1. SearchBar component:",
      "   - Should be a controlled input",
      "   - Accept onSearch callback prop",
      "   - Use the debounce hook internally",
      "   - Include proper label for accessibility",
      "",
      "2. ResultsList component:",
      "   - Accept items array and onItemClick callback as props",
      "   - Show loading spinner when isLoading prop is true",
      "   - Show 'No results found' message when items array is empty",
      "   - Each result card should display: name, category, rating, and price",
      "   - Cards should be clickable and have hover effects",
      "",
      "3. DetailsModal component:",
      "   - Accept item object and onClose callback as props",
      "   - Render nothing (return null) if item is null",
      "   - Show full item details: name, category, rating, price, description, tags",
      "   - Close when clicking the backdrop or close button",
      "   - Prevent backdrop click from closing when clicking modal content (use stopPropagation)",
      "",
      "Keep each component focused on one responsibility."
    ]
  },
  "styling": {
    "title": "Styling Guidelines",
    "content": [
      "Use Tailwind CSS utility classes:",
      "",
      "1. Cards and containers:",
      "   - Use white background with subtle shadows",
      "   - Add hover effects for interactive elements (hover:shadow-md)",
      "   - Use rounded corners (rounded-lg)",
      "   - Add appropriate padding (p-4, p-6)",
      "",
      "2. Typography:",
      "   - Use font-bold for headings",
      "   - Use text-gray-600 for secondary text",
      "   - Use appropriate text sizes (text-lg, text-2xl)",
      "",
      "3. Layout:",
      "   - Use flexbox (flex, gap-4) for horizontal layouts",
      "   - Use grid for card layouts if needed",
      "   - Add proper spacing between sections (space-y-4, mb-4)",
      "",
      "4. Interactive states:",
      "   - Add cursor-pointer to clickable elements",
      "   - Add transition classes for smooth animations",
      "   - Use focus:ring-2 focus:ring-blue-500 for keyboard focus",
      "",
      "Keep styling clean and not bloated. Use Tailwind's defaults where possible."
    ]
  },
  "accessibility": {
    "title": "Accessibility Requirements",
    "content": [
      "Ensure the app is accessible:",
      "",
      "1. Labels and inputs:",
      "   - Every input must have an associated label",
      "   - Use htmlFor on label matching input id",
      "   - Add aria-label for additional context if needed",
      "",
      "2. Semantic HTML:",
      "   - Use <main> for the main content area",
      "   - Use <button> for all clickable actions (never use <div> with onClick)",
      "   - Use proper heading hierarchy (h1, h2, h3)",
      "",
      "3. Keyboard navigation:",
      "   - All interactive elements should be keyboard accessible",
      "   - Test that Tab key cycles through all interactive elements",
      "   - Add visible focus indicators",
      "",
      "4. Screen readers:",
      "   - Add aria-label to buttons that only have icons",
      "   - Use role='status' for loading indicators",
      "   - Make sure modal close button has descriptive text"
    ]
  },
  "stateManagement": {
    "title": "State Management Guidelines",
    "content": [
      "Keep state management simple:",
      "",
      "1. Component state:",
      "   - Use useState for search term, filtered items, selected item, and loading state",
      "   - Don't over-complicate - this is a simple app, no need for Redux or Context",
      "",
      "2. Data flow:",
      "   - Load items from src/data/items.json on component mount",
      "   - Filter items whenever the debounced search term changes",
      "   - Use useMemo to optimize filtering if needed (but probably not necessary)",
      "",
      "3. Loading states:",
      "   - Set isLoading to true before filtering",
      "   - Set to false after filtering completes",
      "   - You can add a small artificial delay (100-200ms) to show the loading state",
      "",
      "4. Modal state:",
      "   - Track selected item in state (Item | null)",
      "   - Set to item object when clicking a result",
      "   - Set to null when closing modal"
    ]
  },
  "typeScript": {
    "title": "TypeScript Guidelines",
    "content": [
      "Use TypeScript properly:",
      "",
      "1. Define the Item interface first:",
      "   - Match the structure in src/data/items.json exactly",
      "   - Include: id (number), name, category, rating, price (all strings), description (string), tags (string[])",
      "",
      "2. Type your component props:",
      "   - Create interface for each component's props",
      "   - Use descriptive names like SearchBarProps, ResultsListProps, etc.",
      "",
      "3. Type your state:",
      "   - useState<string>() for search term",
      "   - useState<Item[]>() for items array",
      "   - useState<Item | null>() for selected item",
      "   - useState<boolean>() for loading state",
      "",
      "4. Type your functions:",
      "   - Add return types to functions when not obvious",
      "   - Type callback props properly: onSearch: (term: string) => void",
      "",
      "Don't use 'any' type unless absolutely necessary."
    ]
  },
  "testing": {
    "title": "Testing Guidelines for Next.js",
    "content": [
      "Write tests for Next.js components and features:",
      "",
      "1. Test setup:",
      "   - Use Jest as test runner",
      "   - Use React Testing Library for component tests",
      "   - Use @testing-library/user-event for interactions",
      "   - Place tests next to components: ComponentName.test.tsx",
      "",
      "2. Next.js specific testing:",
      "   - Mock next/navigation hooks (useRouter, useSearchParams)",
      "   - Mock next/link components if needed",
      "   - Test Client Components with 'use client' directive",
      "   - Focus on Client Components (Server Components harder to test)",
      "",
      "3. What to test:",
      "   - Client Component interactions (typing, clicking)",
      "   - URL search params handling (useSearchParams)",
      "   - Navigation (router.push calls)",
      "   - Component states (loading, empty, with data)",
      "   - Debounce behavior (use jest.useFakeTimers)",
      "   - Accessibility",
      "",
      "4. Testing patterns:",
      "   - Test user behavior, not implementation",
      "   - Use userEvent for realistic interactions",
      "   - Query by role/label when possible",
      "   - Mock only external dependencies",
      "",
      "5. Debounce testing:",
      "   - Use jest.useFakeTimers() at test start",
      "   - Use jest.advanceTimersByTime(300) to simulate delay",
      "   - Use jest.useRealTimers() in cleanup",
      "",
      "6. Installation:",
      "   - npm install -D jest @testing-library/react @testing-library/jest-dom @testing-library/user-event jest-environment-jsdom",
      "",
      "Focus on testing Client Components where user interaction happens."
    ]
  },
    "testReporting": {
    "title": "Test Reports and Coverage",
    "content": [
      "Generate test reports for documentation and CI/CD:",
      "",
      "1. Coverage reports:",
      "   - Run: npm test -- --coverage",
      "   - Generates coverage/ directory with HTML report",
      "   - Open coverage/lcov-report/index.html in browser",
      "   - Shows which lines/branches are covered",
      "",
      "2. Jest configuration for reports (jest.config.js):",
      "   - collectCoverage: false (enable with --coverage flag)",
      "   - coverageDirectory: 'coverage'",
      "   - coverageReporters: ['html', 'text', 'lcov', 'json']",
      "   - collectCoverageFrom: ['src/**/*.{ts,tsx}', '!src/**/*.test.{ts,tsx}']",
      "",
      "3. Coverage thresholds (optional):",
      "   - Set minimum coverage requirements",
      "   - coverageThreshold: { global: { statements: 80, branches: 80, functions: 80, lines: 80 } }",
      "   - Tests fail if coverage drops below threshold",
      "",
      "4. Test results reporters:",
      "   - default: Console output",
      "   - jest-html-reporter: Generates HTML test results",
      "   - jest-junit: Generates XML for CI/CD tools",
      "",
      "5. Package.json scripts:",
      "   - \"test\": \"jest\"",
      "   - \"test:watch\": \"jest --watch\"",
      "   - \"test:coverage\": \"jest --coverage\"",
      "   - \"test:report\": \"jest --coverage --coverageReporters=html text\"",
      "",
      "6. View reports:",
      "   - Coverage: Open coverage/lcov-report/index.html",
      "   - Shows green (covered) and red (uncovered) lines",
      "   - Helps identify what needs testing",
      "",
      "Note: Add coverage/ to .gitignore"
    ]
  }
}